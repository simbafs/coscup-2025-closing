import { createTimeline, Timeline } from 'animejs'
import data from './data.json'

// type definitions

type Member = {
	name: string
	email_hash: string
}

type Group = {
	name: string
	tid: string
	chiefs: Member[]
	members: Member[]
}

type MemberWithChief = {
	member: Member
	isChief: boolean
}

// utility functions

/** 平均的把 arr 切成每個不超過 n 個元素的陣列，並考慮到剩餘元素的情況。[code generated by ChatGPT] */
function chunk<T extends any>(arr: Array<T>, n: number): T[][] {
	const len = arr.length

	// 計算最少需要幾組（ceil 無條件進位）
	let groups = Math.ceil(len / n)

	// 若平均後每組會超過 n，則多切一組
	while (Math.ceil(len / groups) > n) {
		groups++
	}

	const result = []
	let start = 0

	for (let i = 0; i < groups; i++) {
		// 剩下的元素與剩餘組數，決定目前要切幾個
		const remaining = len - start
		const groupsLeft = groups - i
		const size = Math.ceil(remaining / groupsLeft)

		result.push(arr.slice(start, start + size))
		start += size
	}

	return result
}

function getNumberInGroup(): number {
	const screenWidth = document.body.offsetWidth - 500
	const elementWidth = 150

	const number = Math.floor(screenWidth / elementWidth)
	if (number < 1) {
		return 1
	}
	return number
}

// components (function returning DOM elements)

function Member(member: Member, isCheif: boolean = false): HTMLDivElement {
	const m = document.createElement('div')
	m.classList.add('member')

	const avatar = document.createElement('img')
	avatar.src = `https://www.gravatar.com/avatar/${member.email_hash}?s=120&d=identicon&r=g&d=https://volunteer.coscup.org/img/nonavatar.png`
	avatar.alt = member.name
	avatar.height = 120
	avatar.width = 120

	const title = document.createElement('h3')
	title.textContent = isCheif ? '組長' : '　'

	const name = document.createElement('h2')
	name.textContent = member.name

	m.appendChild(avatar)
	m.appendChild(title)
	m.appendChild(name)

	return m
}

function Group(group: Group, n: number) {
	const title = document.createElement('h1')
	title.textContent = group.name

	const cheifs: Set<string> = new Set()
	group.chiefs.forEach(chief => {
		cheifs.add(chief.email_hash)
	})

	const membersList: MemberWithChief[] = [
		...group.chiefs.map(c => ({ member: c, isChief: true })),
		...group.members.filter(m => !cheifs.has(m.email_hash)).map(m => ({ member: m, isChief: false })),
	]

	const chunkedMembers = chunk(membersList, n || 1)

	const members = chunkedMembers.map(c => {
		const m = document.createElement('div')
		m.classList.add('members')
		c.forEach(({ member, isChief }) => {
			m.appendChild(Member(member, isChief))
		})
		return m
	})

	return {
		title,
		members,
	}
}

// others

const titleContainer = document.querySelector('#title')!
const membersContainer: HTMLDivElement = document.querySelector('#members')!

/** Append the given title and slides to timeline. Note that you need to append the element to DOM by your self */
function appendSlides(tl: Timeline, label: string, title: HTMLElement, slides: HTMLElement[]) {
	const speed = 600 / 1000 // px/ms
	const width = document.body.offsetWidth
	const duration = width / speed

	const slidein = {
		translateX: {
			from: width,
			to: 0,
			duration: duration,
			ease: 'linear',
		},
	}

	const slideout = {
		delay: 1000,
		translateX: {
			from: 0,
			to: -width,
			duration: duration,
			ease: 'linear',
		},
	}

	title.style.transform = `translateX(${width}px)`
	slides.forEach(s => (s.style.transform = `translateX(${width}px)`))

	tl.label(label)
	tl.add(title, slidein, '<<')
	slides.forEach(s => {
		tl.add(s, slidein, '<<').add(s, slideout)
	})
	tl.add(title, slideout, '<<')
}

function slideInGroup(tl: Timeline, group: Group) {
	const n = getNumberInGroup()
	const { title, members } = Group(group, n)

	titleContainer.appendChild(title)
	members.forEach(m => {
		membersContainer.appendChild(m)
	})

	appendSlides(tl, group.tid, title, members)
}

function controlPanel(tl: Timeline, groups: Group[]) {
	const pause = () => {
		if (tl.paused) {
			tl.play()
		} else {
			tl.pause()
		}
	}

	const restart = () => tl.restart()

	document.querySelector('#pause')!.addEventListener('click', pause)
	document.querySelector('#restart')!.addEventListener('click', restart)
	document.addEventListener('keydown', e => {
		console.log(e.code)
		switch (e.code) {
			case 'space':
				pause()
				break
			case 'keyR':
				restart()
				break
		}
	})

	const label: HTMLSelectElement = document.querySelector('#label')!
	groups.forEach(g => {
		const option = document.createElement('option')
		option.value = g.tid
		option.textContent = g.name
		label.appendChild(option)
	})

	label.addEventListener('change', e => {
		const tid = (e.target as HTMLSelectElement).value
		if (tid) {
			tl.seek(tl.labels[tid])
		}
	})
	const getCurrent = getCurrentLabel(tl)
	tl.onUpdate = () => {
		const currentLabel = getCurrent(tl.iterationCurrentTime)
		if (currentLabel !== label.value) {
			label.value = currentLabel
		}
	}
}

// Code generated by ChatGPT
function getCurrentLabel(tl: Timeline) {
	return function (currentTime: number) {
		// 將 labels 轉為排序後的 [label, time] 陣列
		const sorted = Object.entries(tl.labels).sort((a, b) => a[1] - b[1])

		let currentLabel = sorted[0][0] // 預設為最早的 label

		for (let i = 0; i < sorted.length; i++) {
			const [label, time] = sorted[i]
			if (currentTime >= time) {
				currentLabel = label
			} else {
				break
			}
		}

		return currentLabel
	}
}

async function main() {
	const tl = createTimeline({
		loop: true,
	})

	for (const group of data.data) {
		slideInGroup(tl, group)
	}

	controlPanel(tl, data.data)
}

main()
